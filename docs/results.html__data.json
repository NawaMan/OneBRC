{"type":"data","nodes":[null,{"type":"data","data":[{"text":1},"package onebrc;\n\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.nio.channels.FileChannel.MapMode.READ_ONLY;\nimport static java.nio.file.StandardOpenOption.READ;\nimport static java.util.concurrent.Executors.newFixedThreadPool;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Paths;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.LinkedBlockingQueue;\n\n/**\n * One-Billion Row Challenge solution by NawaMan.\n * \n * Key Points:\n * \u003Col>\n * \u003Cli>Mapped file to memory for ask IO access.\u003C/li>\n * \u003Cli>Parallel process of data in chunks.\u003C/li>\n * \u003Cli>Chunk separation with minimum overlaps.\u003C/li>\n * \u003Cli>Store name in a fix length byte array \n *         so we don't need to find out the length before create the array.\u003C/li>\n * \u003Cli>Parse the temperature into integer (x10) rather than float/double.\u003C/li>\n * \u003Cli>Reuse name array if one already exists in the collection.\u003C/li>\n * \u003Cli>Pre-calculate hashCode when parsing (finding out start and end).\u003C/li>\n * \u003C/ol>\n */\npublic class CalculateAverage_nawaman {\n    \n    static int cpuCount = Runtime.getRuntime().availableProcessors();\n    \n    static ExecutorService                executor   = newFixedThreadPool(cpuCount);\n    static LinkedBlockingQueue\u003CStatistic> statistics = new LinkedBlockingQueue\u003CStatistic>();\n    \n    /**\n     * Station name\n     * \u003Col>\n     *   \u003Cli>store name as bytes with cached hashCode for used as a map key.\u003C/li>\n     *   \u003Cli>convert to string (cached) when needed proper UTF-8 sorting.\u003C/li>\n     * \u003C/ol>\n     **/\n    static class StationName implements Comparable\u003CStationName> {\n        final byte[] nameArray;\n        final int    nameLength;\n        final int    hashCode;\n        \n        private volatile String toString = null;\n        \n        StationName(byte[] nameArray, int nameLength, int nameHash) {\n            this.nameArray  = nameArray;\n            this.nameLength = nameLength;\n            this.hashCode   = nameHash;\n        }\n        \n        @Override\n        public int hashCode() {\n            return hashCode;\n        }\n        \n        @Override\n        public boolean equals(Object obj) {\n            // Not needed as we are the only one using this class.\n//            if (this == obj)\n//                return true;\n//            if (!(obj instanceof StationName))\n//                return false;\n            \n            var other = (StationName) obj;\n            if (nameLength != other.nameLength)\n                return false;\n            if (hashCode() != other.hashCode())\n                return false;\n            \n            return Arrays.equals(nameArray, 0, nameLength, other.nameArray, 0, nameLength);\n        }\n        \n        @Override\n        public String toString() {\n            if (toString == null) {\n                synchronized (this) {\n                    if (toString == null) {\n                        toString = new String(nameArray, 0, nameLength);\n                    }\n                }\n            }\n            return toString;\n        }\n        \n        @Override\n        public int compareTo(StationName o) {\n            // Avoid handling sorting of UTF-8 characters so convert it to string.\n            return this.toString().compareTo(o.toString());\n        }\n    }\n    \n    /** Station statistic -- This contains statistic from a single station. */\n    static class StationStatistic {\n        StationName stationName;\n        long        min   = Long.MAX_VALUE;\n        long        max   = Long.MIN_VALUE;\n        long        sum   = 0;\n        long        count = 0;\n        \n        static double round(double value) {\n            return Math.round(value * 10.0) / 10.0;\n        }\n        \n        StationStatistic(StationName stationName) {\n            this.stationName = stationName;\n        }\n        \n        /** Add the measurement to the statistic. */\n        void add(int measurement) {\n            min = min(min, measurement);\n            max = max(max, measurement);\n            sum += measurement;\n            count++;\n        }\n        \n        /** Include and combine the data from the given station statistic into this one. */\n        void include(StationStatistic stationStatistic) {\n            min    = min(min, stationStatistic.min);\n            max    = max(max, stationStatistic.max);\n            sum   += stationStatistic.sum;\n            count += stationStatistic.count;\n        }\n        \n        @Override\n        public String toString() {\n            // This is copied from the baseline so that the rounding is the same.\n            return round(min                / 10.0) + \"/\"\n                 + round((round(sum)/count) / 10.0) + \"/\"\n                 + round(max                / 10.0);\n        }\n    }\n    \n    /** Statistic of multiple station -- This contains data from multiple stations and multiple chunk. */\n    static class Statistic {\n        \n        // The max station name is 10,000 but we can start smaller as each extractor only do part of it.\n        // We can afford to have it grow as needed.\n        static final int STATISTIC_MAP_SIZE = 1024;\n        \n        final Set\u003CString>                        chunkNames = new TreeSet\u003CString>();\n        final Map\u003CStationName, StationStatistic> stationData;\n        \n        Statistic(String name, boolean isSorted) {\n            if (name != null) {\n                chunkNames.add(name);\n            }\n            \n            stationData\n                    = isSorted\n                    ? new TreeMap\u003CStationName, StationStatistic>()\n                    : new HashMap\u003CStationName, StationStatistic>(STATISTIC_MAP_SIZE);\n        }\n        \n        /** Add value to the station of the same name and return if the station is newly-added. */\n        boolean addMeasurement(StationName stationName, int measurement) {\n            var isNew   = false;\n            var station = stationData.get(stationName);\n            // Interestingly, using compute(...) is slower than the get and if-else.\n            if (station == null) {\n                station = new StationStatistic(stationName);\n                stationData.put(stationName, station);\n                isNew = true;\n            }\n            station.add(measurement);\n            return isNew;\n        }\n        \n        /** Include and absorb all data from the given statistic */\n        Statistic include(Statistic other) {\n            chunkNames.addAll(other.chunkNames);\n            for (var entry : other.stationData.entrySet()) {\n                var name       = entry.getKey();\n                var newStation = entry.getValue();\n                var station    = stationData.get(name);\n                // Interestingly, using compute(...) is slower than the get and if-else.\n                if (station == null) {\n                    stationData.put(name, newStation);\n                } else {\n                    station.include(newStation);\n                }\n            }\n            return this;\n        }\n        \n        /** Returns the statistic with sorted data. */\n        Statistic sort() {\n            if (stationData instanceof TreeMap)\n                return this;\n            \n            return new Statistic(null, true).include(this);\n        }\n        \n        @Override\n        public String toString() {\n            return stationData.toString();\n        }\n        \n    }\n    \n    /** Extractor to extract data from the buffer.*/\n    static record ChunkExtractor(\n            String     extractorName,\n            ByteBuffer buffer,\n            long       boundarySize) {\n        \n        static final int NAME_BUFFER_SIZE = 128;\n        \n        private static int toDigit(byte nextCh) {\n            return nextCh - '0';\n        }\n        \n        /**\n         * Create an extractor that can read the file from the start to the end.\n         * It skip the part of line that should be processed by the previous extractor.\n         **/\n        static ChunkExtractor create(String name, String filePath, long start, long size) throws IOException {\n            try (var channel = FileChannel.open(Paths.get(filePath), READ)) {\n                // Read a bit longer on the end to ensure that the last line is included.\n                // Since the name of the station is at most 100 bytes, 300 extra bytes are read.\n                // This because, there can be up to 100+ from the previous and 100+ extended into the next part.\n                long sizeToRead = size + 300;\n                \n                // Calculate the start position.\n                // Get one more byte in the front to check if the newline char is at the beginning of a line.\n                // Without this, we do not know if the first read bytes are part of the previous extract\n                //    or a beginning of this extractor.\n                // If the first char is a new line, we know that the next char is the start of the first line.\n                // If the first char is not a newline, we know that it was a tail of the previous extract. \n                long startPosition = max(start - 1, 0);\n                \n                // Calculate the end position.\n                long lastPosition = channel.size();\n                long endPosition  = min(start + sizeToRead, lastPosition);\n                \n                // Read the chunk of the file to the buffer.\n                long mapSize = endPosition - startPosition;\n                var buffer = channel.map(READ_ONLY, startPosition, mapSize);\n                \n                // Adjust the start of the buffer by skipping to the next line if not at the start.\n                long skippedBytes = seekToStart(startPosition, buffer);\n                \n                // The boundary size shrinks because the starting point is adjusted.\n                long boundarySize = size - skippedBytes;\n                return new ChunkExtractor(name, buffer, boundarySize);\n            }\n        }\n        \n        private static long seekToStart(long startPosition, MappedByteBuffer buffer) {\n            long skippedBytes = 0;\n            if (startPosition != 0) {\n                while (buffer.hasRemaining()) {\n                    byte b = buffer.get();\n                    skippedBytes++;\n                    if (b == '\\n')\n                        break;\n                }\n            }\n            return skippedBytes;\n        }\n        \n        /** This class help with the extraction as Java does not support multiple-value return. */\n        static class StationNameData {\n            byte[] bytes = new byte[NAME_BUFFER_SIZE];\n            int    length;\n            int    hash;\n        }\n        \n        /** Extract the data from the buffer into statistic -- stations with statistic data. */\n        Statistic extract() throws IOException {\n            var histogram = new Statistic(extractorName, false);\n            \n            // Reusable station-name data for speed -- by reduce object creation.\n            var stationNameData = new StationNameData();\n            \n            var startPos = buffer.position();\n            var stopPos  = startPos + boundarySize;\n            while (buffer.hasRemaining() && (buffer.position() \u003C= stopPos)) {\n                readStationName(stationNameData);\n                var value = readTemperature();\n                \n                var stationName = new StationName(stationNameData.bytes, stationNameData.length, stationNameData.hash);\n                var isNew       = histogram.addMeasurement(stationName, value);\n                if (isNew) {\n                    // The station name is found to be a new one(for this chunk) so it is now used in the map.\n                    // Since the object are now used, we cannot reuse it.\n                    // Therefore, we need to create a new one.\n                    stationNameData = new StationNameData();\n                }\n            }\n            return histogram;\n        }\n        \n        void readStationName(StationNameData nameData) {\n            var nameBytes = nameData.bytes;\n            int nameIndex = 0;\n            int nameHash  = 1;\n            \n            nameIndex = 0;\n            while (buffer.hasRemaining()) {\n                byte b = buffer.get();\n                if (b == ';')\n                    break;\n                nameBytes[nameIndex++] = b;\n                nameHash = (nameHash \u003C\u003C 5) - nameHash + b;  // nameHash*31 + b\n            }\n            nameData.length = nameIndex;\n            nameData.hash   = nameHash;\n        }\n        \n        // Read temperature from the buffer but read it as times-10 integer representation.\n        // Possible values: -99.0 to 99.9 will now become -990 to 999.\n        int readTemperature() {\n            var sign        = 1;\n            var temperature = 0;\n            // Attempt to read the first digit and sign\n            var firstChar = buffer.get();\n            if (firstChar == '-') {\n                // Found negative sign\n                sign = -1;\n                \n                // Read the next one for the hundredth digit.\n                temperature = toDigit(buffer.get());\n            } else {\n                temperature = toDigit(firstChar);\n            }\n            \n            // If the decimal point is found the first digit becomes the tenth digit.\n            // Otherwise, the first digit the hundredth digit and the second is the tenth digit.\n            var secondCh = buffer.get();\n            if (secondCh == '.') {\n                temperature = temperature * 10;\n            } else {\n                var digit = toDigit(secondCh);\n                temperature = (temperature * 10 + digit)*10;\n                \n                buffer.get(); // Read and throw away the decimal point ('.')\n            }\n            \n            // Getting the digit after the decimal point.\n            int thirdDigit = toDigit(buffer.get());\n            temperature += thirdDigit;\n            \n            // Apply the sign.\n            temperature *= sign;\n            \n            // Read and throw away the new line ('\\n').\n            buffer.get();\n            \n            return temperature;\n        }\n    }\n    \n    //== Main ==\n    \n    public static void main(String[] args) throws IOException, InterruptedException {\n        var filePath   = \"measurements.txt\";\n        var chunkCount = cpuCount;\n        \n        for (var chunkReadTask : chunkExtractTasks(filePath, chunkCount)) {\n            executor.submit(chunkReadTask);\n        }\n        \n        var statistic = (Statistic)null;\n        while (true) {\n            statistic = statistics.take();\n            \n            // No more statistics to combine.\n            if ((statistics.size() == 0)\n             && (statistic.chunkNames.size() == chunkCount))\n                break;\n            \n            var base = statistic;\n            var other = statistics.take();\n            executor.submit(() -> statistics.add(base.include(other)));\n        }\n        \n        System.out.println(statistic.sort());\n        executor.shutdownNow();\n    }\n    \n    /** Create the tasks to extract the data from the file. */\n    private static Runnable[] chunkExtractTasks(String filePath, int chunkCount) throws IOException {\n        long fileSize  = fileSize(filePath);\n        long chunkSize = (fileSize / chunkCount) + 1; // Add some buffer to ensure that the entire file is covered.\n                                                      // Java round integer division down so the sum of each might be\n                                                      //    the actual total.\n        var runnables = new Runnable[chunkCount];\n        for (int i = 0; i \u003C chunkCount; i++) {\n            int cpuIndex  = i;\n            var chunkName = \"Chunk-\" + i;\n            runnables[i] = (() -> {\n                try {\n                    long pos = cpuIndex*chunkSize;\n                    var extractor = ChunkExtractor.create(chunkName, filePath, pos, chunkSize);\n                    var statistic = extractor.extract();\n                    statistics.add(statistic);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            });\n        }\n        return runnables;\n    }\n    \n    /** Get the size of the file so that we can partition the file for each the extractor. */\n    static long fileSize(String filePath) throws IOException {\n        try (var channel = FileChannel.open(Paths.get(filePath), READ)) {\n            return channel.size();\n        }\n    }\n}\n"],"uses":{}}]}
