{"type":"data","nodes":[null,{"type":"data","data":[{"text":1},"package onebrc;\n\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.nio.file.StandardOpenOption.READ;\nimport static java.util.concurrent.Executors.newVirtualThreadPerTaskExecutor;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Paths;\nimport java.util.Arrays;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.Random;\nimport java.util.TreeMap;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.stream.Stream;\n\n/**\n * One-Billion Row Challenge solution by NawaMan.\n * \n * Key Points:\n * \u003Col>\n * \u003Cli>Mapped file to memory for ask IO access.\u003C/li>\n * \u003Cli>Parallel process of data in chunks.\u003C/li>\n * \u003Cli>Chunk separation with minimum overlaps.\u003C/li>\n * \u003Cli>Store name in a fix length byte array \n *         so we don't need to find out the length before create the array.\u003C/li>\n * \u003Cli>Parse the temperature into integer (x10) rather than float/double.\u003C/li>\n * \u003Cli>Reuse name array if one already exists in the collection.\u003C/li>\n * \u003Cli>Pre-calculate hashCode when parsing (finding out start and end).\u003C/li>\n * \u003C/ol>\n */\npublic class CalculateAverage_nawaman {\n    \n    static double round(double value) {\n        return Math.round(value * 10.0) / 10.0;\n    }\n    \n    static Function\u003CStationStatistic, String> defaultToString = statisic -> {\n        return round(statisic.min                            / 10.0) + \"/\"\n                + round((round(statisic.sum)/statisic.count) / 10.0) + \"/\"\n                + round(statisic.max                         / 10.0);\n    };\n    \n    static Function\u003CStationStatistic, String> validateToString = statisic -> {\n        return round(statisic.min   / 10.0) + \"/\"\n             + round(statisic.sum   / 10.0) + \"/\"\n             + round(statisic.count /  1.0) + \"/\"\n             + round(statisic.max   / 10.0);\n    };\n    \n    static Function\u003CStationStatistic, String> stationStatisticToString = defaultToString;\n    \n    static class StationName implements Comparable\u003CStationName> {\n        \n        static final int NAME_BUFFER_SIZE = 128;\n        \n        private byte[] bytes = new byte[NAME_BUFFER_SIZE];\n        private int    length;\n        private int    hash;\n        private int    id = -1;\n        \n        private volatile String toString = null;\n        \n        void readFrom(ByteBuffer buffer) {\n            var bytes     = this.bytes;\n            int nameIndex = 0;\n            int nameHash  = 1;\n            \n            nameIndex = 0;\n            while (buffer.hasRemaining()) {\n                byte b = buffer.get();\n                if (b == ';')\n                    break;\n                bytes[nameIndex++] = b;\n                nameHash = (nameHash \u003C\u003C 6) - nameHash + b;  // nameHash*31 + b\n            }\n            \n            this.bytes  = bytes;\n            this.length = nameIndex;\n            this.hash   = nameHash;\n        }\n        \n        @Override\n        public int hashCode() {\n            return hash;\n        }\n        \n        @Override\n        public boolean equals(Object obj) {\n            // Not needed as we are the only one using this class.\n//            if (this == obj)\n//                return true;\n//            if (!(obj instanceof StationName))\n//                return false;\n            \n            var other = (StationName) obj;\n            if (length != other.length)\n                return false;\n            if (hash != other.hash)\n                return false;\n            \n            if (id != -1 && other.id != -1)\n                return id == other.id;\n            \n            return Arrays.equals(bytes, 0, length, other.bytes, 0, length);\n        }\n        \n        @Override\n        public String toString() {\n            if (toString == null) {\n                synchronized (this) {\n                    if (toString == null) {\n                        toString = new String(bytes, 0, length);\n                    }\n                }\n            }\n            return toString;\n        }\n        \n        @Override\n        public int compareTo(StationName o) {\n            // Avoid handling sorting of UTF-8 characters myself so convert it to string.\n            return this.toString().compareTo(o.toString());\n        }\n    }\n    \n    static class StationNames implements Runnable {\n        private final Random random = new Random();\n        \n        private final Map\u003CStationName, Integer> stationNameIds   = new ConcurrentHashMap\u003C>();\n        private final Queue\u003CStationName>        stationNameQueue = new ConcurrentLinkedQueue\u003C>();\n        \n        void add(StationName stationName) {\n            stationNameQueue.add(stationName);\n        }\n        \n        public void run() {\n            assignStationNameId();\n        }\n        \n        void assignStationNameId() {\n            try {\n                while (true) {\n                    var stationName = stationNameQueue.poll();\n                    if (stationName == null) {\n                        Thread.sleep(0);\n                        continue;\n                    }\n                    \n                    stationName.id = stationNameIds.computeIfAbsent(stationName, (name) -> {\n                        return random.nextInt(0, Integer.MAX_VALUE);\n                    });\n                }\n            } catch (InterruptedException e) {\n            }\n        }\n    }\n    \n    static class TemperatureBuffer {\n        int temperatureTimesTen;\n        \n        static int toDigit(byte nextCh) {\n            return nextCh - '0';\n        }\n        \n        void readFrom(ByteBuffer buffer) {\n            var sign        = 1;\n            var temperature = 0;\n            \n            var firstChar = buffer.get();\n            if (firstChar == '-') {\n                sign = -1;  // Found negative sign\n                temperature = toDigit(buffer.get());\n            } else {\n                temperature = toDigit(firstChar);\n            }\n            \n            var secondCh = buffer.get();\n            if (secondCh != '.') {\n                temperature = temperature * 10 + toDigit(secondCh);\n                buffer.get(); // Read and throw away the decimal point ('.')\n            }\n            \n            temperature = temperature * 10;\n            \n            // Getting the digit after the decimal point.\n            temperature += toDigit(buffer.get());\n            \n            buffer.get();   // Read and throw away the new line ('\\n').\n            \n            this.temperatureTimesTen = sign * temperature;\n        }\n    }\n    \n    static class StationStatistic {\n        \n        StationName stationName;\n        long        min   = Long.MAX_VALUE;\n        long        max   = Long.MIN_VALUE;\n        long        sum   = 0;\n        long        count = 0;\n        \n        StationStatistic(StationName stationName) {\n            this.stationName = stationName;\n        }\n        \n        void add(int temperatureTimesTen) {\n            min  = min(min, temperatureTimesTen);\n            max  = max(max, temperatureTimesTen);\n            sum += temperatureTimesTen;\n            count++;\n        }\n        \n        void include(StationStatistic stationStatistic) {\n            min    = min(min, stationStatistic.min);\n            max    = max(max, stationStatistic.max);\n            sum   += stationStatistic.sum;\n            count += stationStatistic.count;\n        }\n        \n        @Override\n        public String toString() {\n            return stationStatisticToString.apply(this);\n        }\n    }\n    \n    static class Statistic {\n        \n        // The max station name is 10,000 but we can start smaller as each extractor only do part of it.\n        static final int STATISTIC_MAP_SIZE = 1024;\n        \n        int chunkCount = 0;\n        final Map\u003CStationName, StationStatistic> stationStatistics;\n        \n        Statistic(int chunkCount, boolean isSorted) {\n            this.chunkCount = chunkCount;\n            stationStatistics = isSorted\n                        ? new TreeMap\u003CStationName, StationStatistic>()\n                        : new ConcurrentHashMap\u003CStationName, StationStatistic>(STATISTIC_MAP_SIZE);\n        }\n        \n        StationStatistic computeIfAbsent(StationName stationName, Function\u003CStationName, StationStatistic> mappingFunction) {\n            return stationStatistics.computeIfAbsent(stationName, mappingFunction);\n        }\n        \n        Statistic absorb(Statistic other) {\n            chunkCount += other.chunkCount;\n            other.stationStatistics.forEach((name, otherStation) -> {\n                stationStatistics.compute(name, (k, station) -> {\n                    if (station == null) {\n                        return otherStation;\n                    }\n                    station.include(otherStation);\n                    return station;\n                });\n            });\n            return this;\n        }\n        \n        Statistic sorted() {\n            return new Statistic(0, true).absorb(this);\n        }\n        \n        @Override\n        public String toString() {\n            return stationStatistics.toString();\n        }\n        \n    }\n    \n    static record StatisticExtractor(ByteBuffer buffer) {\n        \n        static StatisticExtractor create(String filePath, long start, long estimatedSize) throws IOException {\n            try (var channel = FileChannel.open(Paths.get(filePath), READ)) {\n                // Read a bit longer on the end to ensure that the last line is included.\n                // Since the name of the station is at most 100 bytes, 300 extra bytes are read.\n                // This because, there can be up to 100+ from the previous and 100+ extended into the next part.\n                var tailMargin = 300L;\n                var sizeToRead = estimatedSize + tailMargin;\n                \n                // Get one more byte in the front to check if the newline char is at the beginning of a line.\n                // Without this, we do not know if the first read bytes are part of the previous extract\n                //    or a beginning of this extractor.\n                // If the first char is a new line, we know that the next char is the start of the first line.\n                // If the first char is not a newline, we know that it was a tail of the previous extract. \n                long startPosition = max(start - 1, 0);\n                \n                var lastPosition = channel.size();\n                var endPosition  = min(start + sizeToRead, lastPosition);\n                var mapSize      = endPosition - startPosition;\n                var mappedBuffer = channel.map(FileChannel.MapMode.READ_ONLY, startPosition, mapSize);\n                \n                var chunkStart = seekStartPosition(mappedBuffer, startPosition);\n                var chunkEnd   = seekEndPosition(mappedBuffer, estimatedSize);\n                \n                mappedBuffer.position((int)chunkStart);\n                mappedBuffer.limit   ((int)chunkEnd);\n                var slicedBuffer = mappedBuffer.slice();\n                slicedBuffer.position(0);\n                \n                return new StatisticExtractor(slicedBuffer);\n            }\n        }\n        \n        static long seekStartPosition(ByteBuffer buffer, long startPosition) {\n            if (startPosition == 0)\n                return 0;\n            \n            var start = buffer.position();\n            findNewLine(buffer);\n            \n            return buffer.position() - start;\n        }\n        \n        static int seekEndPosition(ByteBuffer buffer, long boundarySize) {\n            if (boundarySize > buffer.limit())\n                return buffer.limit();\n            \n            buffer.position((int)boundarySize);\n            findNewLine(buffer);\n            \n            return buffer.position();\n        }\n        \n        private static final void findNewLine(ByteBuffer buffer) {\n            while (buffer.hasRemaining()) {\n                if (buffer.get() == '\\n')\n                    return;\n            }\n        }\n        \n        Statistic extract(StationNames names) throws IOException {\n            var statistic   = new Statistic(1, false);\n            var stationName = new StationName();\n            var temperature = new TemperatureBuffer();\n            while (buffer.hasRemaining()) {\n                stationName.readFrom(buffer);\n                temperature.readFrom(buffer);\n                \n                var station = statistic.computeIfAbsent(stationName, StationStatistic::new);\n                station.add(temperature.temperatureTimesTen);\n                \n                var isFirstOfKind = station.stationName == stationName;\n                if (isFirstOfKind) {\n                    // Add to station queue so that we can assign ID to it to make the merge much faster.\n                    names.add(station.stationName);\n                    \n                    // The buffer is not reusable once it is used in the map, so we need to create a new one.\n                    stationName = new StationName();\n                }\n            }\n            return statistic;\n        }\n    }\n    \n    public static void main(String[] args) throws InterruptedException {\n        useValidateToStringIfSpecified(args);\n        \n        var startTime = System.currentTimeMillis();\n        \n        var filePath   = \"measurements.txt\";\n        var cpuCount   = Runtime.getRuntime().availableProcessors();\n        var chunkCount = 32 * cpuCount;\n        \n        var executor   = newVirtualThreadPerTaskExecutor();\n        var statistics = new LinkedBlockingQueue\u003CStatistic>();\n        \n        var stationNames = new StationNames();\n        var nameAssigner = new Thread(stationNames);\n        nameAssigner.start();\n        \n        for (var extractionTask : extractionTasks(stationNames, filePath, chunkCount, statistics::add)) {\n            executor.submit(extractionTask);\n        }\n        \n        var statistic = (Statistic)null;\n        while (true) {\n            statistic = statistics.take();\n            \n            var lastInQueue      = statistics.size() == 0;\n            var includeAllChunks = statistic.chunkCount == chunkCount;\n            var isLastStatistic  =  lastInQueue && includeAllChunks;\n            if (isLastStatistic) {\n                break;\n            }\n            \n            var baseStatistic  = statistic;\n            var otherStatistic = statistics.take();\n            executor.submit(() -> statistics.add(baseStatistic.absorb(otherStatistic)));\n        }\n        \n        nameAssigner.interrupt();\n        executor.shutdownNow();\n        \n        System.out.println(statistic.sorted());\n        \n        System.out.println(\"Time: \" + (System.currentTimeMillis() - startTime) + \"ms\");\n    }\n    \n    private static void useValidateToStringIfSpecified(String[] args) {\n        if (args.length > 0) {\n            Stream.of(args).forEach(arg -> {\n                if (arg.equals(\"--validate\")) {\n                    stationStatisticToString = validateToString;\n                }\n            });\n        }\n    }\n    \n    static Runnable[] extractionTasks(StationNames names, String filePath, int chunkCount, Consumer\u003CStatistic> resultAccepter) {\n        long fileSize  = fileSize(filePath);\n        long chunkSize = (fileSize / chunkCount) + 1; // Add some buffer to ensure that the entire file is covered.\n                                                      // Java round integer division down so the sum of each might be\n                                                      //    the actual total.\n        var runnables = new Runnable[chunkCount];\n        for (int i = 0; i \u003C chunkCount; i++) {\n            int cpuIndex  = i;\n            runnables[i] = (() -> extractionTask(names, filePath, cpuIndex, chunkSize, resultAccepter));\n        }\n        return runnables;\n    }\n    \n    static void extractionTask(StationNames names, String filePath, int chunkIndex, long chunkSize, Consumer\u003CStatistic> accepter) {\n        var position= chunkIndex*chunkSize;\n        try {\n            var extractor = StatisticExtractor.create(filePath, position, chunkSize);\n            var statistic = extractor.extract(names);\n            accepter.accept(statistic);\n        } catch (IOException e) {\n            var message\n                    = \"Panic: Failed to read file chunk! filePath=%s, chunkIndex=%d, chunkSize=%d, position=%d\"\n                    .formatted(filePath, chunkIndex, chunkSize, position);\n            throw new Error(message, e);\n        }\n    }\n    \n    static long fileSize(String filePath) {\n        try (var channel = FileChannel.open(Paths.get(filePath), READ)) {\n            return channel.size();\n        } catch (IOException e) {\n            var message = \"Panic: Failed to get file size! filePath=%s\".formatted(filePath);\n            throw new Error(message, e);\n        }\n    }\n    \n}"],"uses":{}}]}
